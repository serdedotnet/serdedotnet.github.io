<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>serde-dn</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">serde-dn</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="text-align: right;">
  <a style="color: var(--icons);" href="https://github.com/serdedotnet/serde">View on GitHub</a>
</div>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Serde.NET is a .NET port of the popular <a href="https://serde.rs">serde.rs</a> Rust <strong>ser</strong>ialization/<strong>de</strong>serialization library.</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>Unlike many other serialization libraries, Serde.NET is <em>multi-format</em>, <em>high performance</em>, <em>source-generated</em>, and fully compatible with <a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained">app trimming</a> and <a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/native-aot">Native AOT</a>.</p>
<p>Most other .NET serialization libraries rely on run-time reflection to serialize types. Serde instead uses two interfaces, <code>ISerialize</code>, and <code>IDeserialize</code> to allow each type to control how it is serialized. Serde.NET uses source generation to implement these interfaces, so you almost never need to implement them manually. Source generation and interfaces avoids all run-time reflection and its overhead, and provides type and memory safety by ensuring all requested types support serialization. Serde.NET also does not have any unsafe code.</p>
<h2 id="formats"><a class="header" href="#formats">Formats</a></h2>
<p>Serde.NET is a multi-format serialization library, with built-in support for JSON.</p>
<p>Serde.NET is multi-format because it separates how a type serializes itself from the knowledge of the data format. Rather than have individual interfaces for each format, serde uses <code>ISerialize</code> and <code>IDeserialize</code> for all formats. Adding support for new formats comes from implementing two different interfaces: <code>ISerializer</code> and <code>IDeserializer</code>. Since each interface pair is separate, new data format support can be added via NuGet packages.</p>
<p>Supported formats:</p>
<ul>
<li>JSON, the flagship format. Bundled with Serde.NET.</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>This full sample is also available in the <a href="https://github.com/agocke/serde/tree/main/samples/intro">Github repo</a>.</p>
<p>Steps to get started:</p>
<ol>
<li>Add the <code>serde</code> NuGet package:</li>
</ol>
<pre><code class="language-bash">$ dotnet add package serde
</code></pre>
<ol start="2">
<li>Add the <code>partial</code> modifier to the type you want to serialize/deserialize.</li>
<li>Add one of the <code>[GenerateSerde]</code>, <code>[GenerateSerialize]</code>, or <code>[GenerateDeserialize]</code> attributes.</li>
</ol>
<pre><code class="language-c#">using Serde;
using Serde.Json;

string output = JsonSerializer.Serialize(new SampleClass());

// prints: {"X":3,"Y":"sample"}
Console.WriteLine(output);

var deserialized = JsonSerializer.Deserialize&lt;SampleClass&gt;(output);

// prints SampleClass { X = 3, Y = sample }
Console.WriteLine(deserialized);

[GenerateSerde]
partial record SampleClass
{
    // automatically includes public properties and fields
    public int X { get; init; } = 3;
    public string Y = "sample";
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-source-generator"><a class="header" href="#using-the-source-generator">Using the source generator</a></h1>
<p>Serde-dn is type-safe, meaning that it requires every serializing type to implement <code>ISerialize</code> or <code>IDeserialize</code> and <em>always</em> uses an interface implementation for controlling serialization.</p>
<p>For types you control, you could implement those interfaces manually, but most cases can be solved by using the built-in source generator. Two changes are required to use the source generator:</p>
<ol>
<li>Make the type <code>partial</code>.</li>
<li>Add the <code>GenerateSerialize</code> or <code>GenerateDeserialize</code> attribute.</li>
</ol>
<p>For example,</p>
<pre><code class="language-C#">class SampleClass
{
  ...
}
</code></pre>
<p>would become</p>
<pre><code class="language-C#">[GenerateSerialize]
partial class SampleClass
{
  ...
}
</code></pre>
<p>By default, the source generator will include all the public properties <em>and</em> public fields. The field or property types must either,</p>
<ol>
<li>Be a serde-dn built-in type, like <code>int</code> or <code>string</code>.</li>
<li>If the type is in the current assembly, implement <code>I(De)Serialize</code>.</li>
<li>Be defined in an external assembly, where the source generator will automatically wrap the type (see <a href="generator/./wrappers.html">generated wrappers</a>).</li>
<li>Define a <a href="generator/./wrappers.html">wrapper type</a> in the current assembly named <code>&lt;TypeName&gt;Wrap</code> in the <code>Serde</code> namespace.</li>
<li>Specify a custom wrapper.</li>
</ol>
<p>The types of the fields and properties must also implement ISerialize. Many of the most common types, like <code>int</code>, <code>string</code>, or even <code>List&lt;string&gt;</code>, have built-in support from serde-dn and already have ISerialize implementations. If any of those public fields or properties have a type that you control, they will also need to implement <code>ISerialize</code> or <code>IDeserialize</code>. This is also true for nested references, e.g. <code>List&lt;MyOtherType&gt;</code>.</p>
<p>If you don't control any of the types you need to serialize or deserialize (i.e., they are defined in another assembly that you can't modify) you'll need to use a <em>wrapper</em> to implement the interface. See <a href="generator/./wrappers.html">wrappers</a> for more info.</p>
<h2 id="additional-ideserialize-requirements"><a class="header" href="#additional-ideserialize-requirements">Additional IDeserialize requirements</a></h2>
<p>Serde-dn is type safe and always uses reflection-free C# code. Thus, to implement IDeserialize the type must have an accessible constructor and accessible members.</p>
<p>By default, serde-dn requires</p>
<ol>
<li>A parameterless constructor</li>
<li>All fields and properties are writable during creation.</li>
</ol>
<p>If this isn't possible, the constructor used and the properties can be configured through the <code>SerdeTypeOptions</code> attribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-options"><a class="header" href="#configuration-options">Configuration options</a></h1>
<p>Serde-dn provides a variety of options that can be specified via attributes to configure the generated serialization and deserialization implementations.</p>
<p>To apply options to an entire type and all its members, use <code>[SerdeTypeOptions]</code>. To apply options to one member in particular, use <code>[SerdeMemberOptions]</code>.</p>
<h2 id="type-options"><a class="header" href="#type-options">Type options</a></h2>
<p>Note that these options only apply to the target type, not the type of nested members (including ones which have wrappers auto-generated). To provide options for member types the attribute will also need to be applied to them (or their wrapper).</p>
<ul>
<li>
<p><code>[SerdeTypeOptions(MemberFormat = ...)]</code></p>
<p><code>MemberFormat.CamelCase</code> by default. Renames all the fields or properties of the generated implementation according to the given format. The possible formats are "camelCase", "PascalCase", "kebab-case", and "none". "none" means that the members should not be renamed.</p>
</li>
<li>
<p><code>[SerdeTypeOptions(SerializeNull = false)]</code></p>
<p><code>false</code> by default. When false, serialization for members will be skipped if the value is null. When true, null will be serialized like all other values.</p>
</li>
<li>
<p><code>[SerdeTypeOptions(DenyUnknownMembers = false)]</code></p>
<p><code>false</code> by default. When false, the generated implementation of <code>IDeserialize</code> will skip over any members in the source that aren't defined on the type. When true, an exception will be thrown if there are any unrecognized members in the source.</p>
</li>
</ul>
<h2 id="member-options"><a class="header" href="#member-options">Member options</a></h2>
<ul>
<li>
<p><code>[SerdeMemberOptions(ThrowIfMissing = false)]</code></p>
<p><code>false</code> by default. When true, throws an exception if the target field is not present when deserializing.  This is the default behavior for fields of non-nullable types, while the default behavior for nullable types is to set the field to null.</p>
</li>
<li>
<p><code>[SerdeMemberOptions(SerializeNull = false)]</code></p>
<p><code>false</code> by default. When false, serialization for this member will be skipped if the value is null. When true, null will be serialized like all other values.</p>
</li>
<li>
<p><code>[SerdeMemberOptions(Rename = "name")]</code></p>
<p><code>null</code> by default. When not null, renames the current member to the given argument.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customization"><a class="header" href="#customization">Customization</a></h1>
<p>Wrappers are an essential part of the serde-dn design. Many types aren't under user control and won't be able to implement the <code>ISerialize</code> or <code>IDeserialize</code> interfaces directly. Instead, simple wrapper structs are used to proxy the target type.</p>
<p>Often, wrappers will be created for you as necessary. If you are serializing a type you define, the source generator will automatically create wrappers for nested external types. However, wrappers will never be automatically created for types in your source code. If you control the type, it must implement the required interfaces directly.</p>
<h2 id="creating-a-wrapper-type"><a class="header" href="#creating-a-wrapper-type">Creating a wrapper type</a></h2>
<p>By convention, wrappers are named <code>&lt;OriginalTypeName&gt;Wrap</code> and are always placed in the <code>Serde</code> namespace. Since wrappers are normal C#, you could choose to implement the <code>ISerialize</code> or <code>IDeserialize</code> logic yourself, just as you would for a custom implementation on your own type. However, the serde-dn source generator also has support for generating implementations for wrappers.</p>
<p>To use implement via source generator do the following:</p>
<ol>
<li>Create a wrapper type (often a struct) named <code>&lt;OriginalTypeName&gt;Wrap</code> in the <code>Serde</code> namespace.</li>
<li>Make it <code>partial</code>.</li>
<li>Add a field or property to store the wrapped instance.</li>
<li>Add the <code>[GenerateWrapper]</code> attribute and pass it the name of your field or property as a string (maybe using <code>nameof</code>)</li>
</ol>
<p>The "records" feature is particularly useful for this:</p>
<pre><code class="language-C#">using Serde;

// Type we can't modify
class ExternalClass { ... }

namespace Serde
{
    [GenerateWrapper(nameof(Value))]
    partial readonly record struct ExternalClassWrap(ExternalClass Value);
}
</code></pre>
<p>By default, this will implement both <code>ISerialize</code> and <code>IDeserialize</code> in the wrapper.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-types"><a class="header" href="#external-types">External types</a></h1>
<p>Sometimes you need to serialize or deserialize a type you don't control or can't modify. In these cases, Serde uses a "proxy type" to stand-in for the external type. To create a proxy type, simply create a new class and add the attribute <code>[GenerateSerde(ForType = typeof(ExternalType)]</code>. Serde will automatically use the public properties and fields on the external type if the proxy type is empty. Here's a simple example that assumes there's an external <code>Response</code> record that you can't modify.</p>
<pre><code class="language-csharp">
using System;
using Serde;
using Serde.Json;

namespace ExternalTypesSample;

// Pretend that Response is an external type that we can't modify directly
public record Response(string ResponseType, string Body);

// Proxy for the Response type.
// We use the [GenerateSerde] attribute with the `ForType` parameter to control generation for the
// proxy type. Since the ResponseProxy type is empty, Serde will assume that we want to automatically
// use all the public properties and fields of the Response type, with no further customization.
[GenerateSerde(ForType = typeof(Response))]
partial class ResponseProxy;

public class Sample
{
    public static void Run()
    {
        var resp = new Response(ResponseType: "success", Body: "hello, world");
        Console.WriteLine($"Original version: {resp}");

        // Serialize the Response to a JSON string
        // In addition to the Response type, we also have to pass in the proxy type
        var json = JsonSerializer.Serialize&lt;Response, ResponseProxy&gt;(resp);
        Console.WriteLine($"Serialized version: {json}");

        // Deserialize the JSON string back to a Response object
        var deResp = JsonSerializer.Deserialize&lt;Response, ResponseProxy&gt;(json);
        Utils.AssertEq(resp, deResp);
        Console.WriteLine($"Deserialized version: {deResp}");
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-generic-types"><a class="header" href="#handling-generic-types">Handling generic types</a></h1>
<p>For most types, adding Serde.NET support is as easy as implementing the <code>ISerialize</code> and <code>IDeserialize</code> interfaces, which the source generator can do for you.</p>
<p>Generic types are usually not so easy, because of a specific restriction in the .NET type system.</p>
<p>Let's say you have a simple custom generic list type, like <code>MyList&lt;T&gt;</code>. Serde already provides built-in support for automatically wrapping Lists using <a href="https://github.com/serdedotnet/serde/blob/main/src/serde/Wrappers.List.cs">prewritten wrappers</a>, but you might have a customization you want to provide. In that case you might try implementing <code>ISerialize</code> and <code>IDeserialize</code> yourself, but run into a problem -- for <code>MyList&lt;T&gt;</code> to be serializable, all its elements (<code>T</code>) must be serializable.</p>
<p>The natural inclination would be to add a constraint to the <code>MyList&lt;T&gt;</code> definition: <code>MyList&lt;T&gt; where T : ISerialize&lt;T&gt;, IDeserialize&lt;T&gt;</code>. Unfortunately, that won't work. First, it would create a requirement that you could only put serializable elements into the <code>MyList&lt;T&gt;</code> type. However, that's not the contract you want to provide. You want to support serialization in the case that all types are serializable, but you don't want to <em>require</em> that all types be serializable. Second, even the primitive types, like <code>int</code> and <code>string</code>, don't implement <code>ISerialize&lt;T&gt;</code> or <code>IDeserialize&lt;T&gt;</code> directly -- they use wrappers.</p>
<p>So what's the solution? Using a wrapper type instead. Rather than implement serialization on <code>MyList&lt;T&gt;</code> itself, define a wrapper type for Serde, then point to that wrapper type from the <code>MyList&lt;T&gt;</code> definition. The information at <a href="./generator/wrappers.html">Wrappers</a> is very useful as background.</p>
<p>One important point is that generic wrappers are slightly different from regular wrappers. To be more flexible they provide serialization and deserialization separately, and therefore are implemented using a different pattern. They start with a static class at the top level, and feature a <code>SerializeImpl</code> and <code>DeserializeImpl</code> nested beneath. For <code>MyList&lt;T&gt;</code> this would look like,</p>
<pre><code class="language-C#">public static class MyListSerdeWrap
{
    public readonly record struct SerializeImpl&lt;T, TWrap&gt;(MyList&lt;T&gt; Value) : ISerialize, ISerialize&lt;MyList&lt;T&gt;&gt;
        where TWrap : struct, ISerialize, ISerialize&lt;T&gt;, ISerializeWrap&lt;T, TWrap&gt;
    {
        ...
    }
    public readonly record struct DeserializeImpl&lt;T, TWrap&gt; : IDeserialize&lt;MyList&lt;T&gt;&gt;
        where TWrap : IDeserialize&lt;T&gt;
    {
        ...
    }
}
</code></pre>
<p>Note that each nested class takes at least two type parameters. The first type parameter is for the type parameter of the original type. The second is for the wrapper that might be needed for previous type parameter. The rule is that for <code>n</code> type parameters on the original type, you'll need <code>2n</code> type paramaeters for the wrapper type.</p>
<p>The implementation of the wrapper is otherwise standard. For collections, you can reference the <a href="https://github.com/serdedotnet/serde/blob/main/src/serde/Wrappers.List.cs">prewritten List and Dictionary wrappers</a> for implementation tips.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
